# 算法刷题笔记
   2021年4月6日，开始进行算法学习，之前了解过一些数据结构和算法知识，但是学习过于零散，从今日起开始刷算法题，并记录解题的心路历程，接触题目增加之后争取为题目的解法做归类，重在培养算法头脑。每天一道，多退少补。
## 数组交集(2021.04.06)
### 题目
```markdown
给定两个数组，编写一个函数来计算它们的交集。
```
### 心路历程
   第一想法是两个for循环嵌套，第一个数组在外层，第二个在内层，如果相等，就存到另一个数组中。这种可以实现，但是肯定是错误答案，感觉这种算法题应该是尽量不用嵌套for循环的方式解决。
   然后就不会了。。。翻解题方法，居然用了映射。先放解题方法。

### 解题方法
``````java
public static Integer[] intersection(int[] num1, int[] num2) {
    Map<Integer, Integer> map = new HashMap<>();
    for (Integer i : num1) {
        map.put(i, map.getOrDefault(i, 0) + 1);
    }
    List<Integer> list = new ArrayList<>();
    for (Integer j : num2) {
        int a = map.getOrDefault(j, 0);
        if (a > 0) {
            list.add(j);
            map.put(j, --a);
        }
    }
    return list.toArray(new Integer[0]);
}
``````
### 题解分析
   从代码中可以看出来，第一个for循环遍历num1，map的key值为数组的元素，value为该元素出现的次数。第二个for循环遍历num2，并把在map中获取每个元素对应在num1中出现的次数(出现次数大于0)，如果命中，则拿到该元素，次数减1。这样可以得到两个数组元素的交集。
   这种想法对于我来说是很独特的，map在存储数据的时候，存储的是键值对，也就是两个数据，而且获取某个值不需要遍历，使得每个元素“有状态”，键用来存储元素，值存储出现次数，这样可以规避两个数组直接比较。让我想起来之前做的一道用数组下标作为值，对应元素存储出现次数的题，和本题大同小异，只不过如果求交集的两个数组元素跨度太大的话，创建的额外数组就会很长，而且浪费空间。**感觉这样的思想会自成一派，后续学习需要重视。**
### 题目进阶
	如果给定的数组已经排好序呢？将如何优化你的算法呢？
### 解题方法
``````java
public static Integer[] intersection2(int[] num1, int[] num2) {
    int index1 = 0;
    int index2 = 0;
    List<Integer> list = new ArrayList<>();
    while (index1 < num1.length && index2 < num2.length) {
        if (num1[index1] == num2[index2]) {
            list.add(num1[index1]);
            index1++;
            index2++;
        } else if (num1[index1] < num2[index2]) {
            index1++;
        } else {
            index2++;
        }
    }
    return list.toArray(new Integer[0]);
}
``````
### 题解分析
   由于两个数组已经排好顺序了，可以针对数组元素进行比较，可以使用指针的概念，两个指针，默认都指向第一个元素，如果相等，则同时向后移动，否则元素小的移动(两个数组以从小到大的顺序排好)。