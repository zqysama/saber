# 算法刷题笔记
   2021年4月6日，开始进行算法学习，之前了解过一些数据结构和算法知识，但是学习过于零散，从今日起开始刷算法题，并记录解题的心路历程，接触题目增加之后争取为题目的解法做归类，重在培养算法头脑。每天一道，多退少补。
## 数组交集(2021.04.06)
### 题目
```markdown
给定两个数组，编写一个函数来计算它们的交集。
```
### 心路历程
   第一想法是两个for循环嵌套，第一个数组在外层，第二个在内层，如果相等，就存到另一个数组中。这种可以实现，但是肯定是错误答案，感觉这种算法题应该是尽量不用嵌套for循环的方式解决。
   然后就不会了。。。翻解题方法，居然用了映射。先放解题方法。

### 解题方法
``````java
public static Integer[] intersection(int[] num1, int[] num2) {
    Map<Integer, Integer> map = new HashMap<>();
    for (Integer i : num1) {
        map.put(i, map.getOrDefault(i, 0) + 1);
    }
    List<Integer> list = new ArrayList<>();
    for (Integer j : num2) {
        int a = map.getOrDefault(j, 0);
        if (a > 0) {
            list.add(j);
            map.put(j, --a);
        }
    }
    return list.toArray(new Integer[0]);
}
``````
### 题解分析
   从代码中可以看出来，第一个for循环遍历num1，map的key值为数组的元素，value为该元素出现的次数。第二个for循环遍历num2，并把在map中获取每个元素对应在num1中出现的次数(出现次数大于0)，如果命中，则拿到该元素，次数减1。这样可以得到两个数组元素的交集。
   这种想法对于我来说是很独特的，map在存储数据的时候，存储的是键值对，也就是两个数据，而且获取某个值不需要遍历，使得每个元素“有状态”，键用来存储元素，值存储出现次数，这样可以规避两个数组直接比较。让我想起来之前做的一道用数组下标作为值，对应元素存储出现次数的题，和本题大同小异，只不过如果求交集的两个数组元素跨度太大的话，创建的额外数组就会很长，而且浪费空间。**感觉这样的思想会自成一派，后续学习需要重视。**
### 题目进阶
	如果给定的数组已经排好序呢？将如何优化你的算法呢？
### 解题方法
``````java
public static Integer[] intersection2(int[] num1, int[] num2) {
    int index1 = 0;
    int index2 = 0;
    List<Integer> list = new ArrayList<>();
    while (index1 < num1.length && index2 < num2.length) {
        if (num1[index1] == num2[index2]) {
            list.add(num1[index1]);
            index1++;
            index2++;
        } else if (num1[index1] < num2[index2]) {
            index1++;
        } else {
            index2++;
        }
    }
    return list.toArray(new Integer[0]);
}
``````
### 题解分析
   由于两个数组已经排好顺序了，可以针对数组元素进行比较，可以使用指针的概念，两个指针，默认都指向第一个元素，如果相等，则同时向后移动，否则元素小的移动(两个数组以从小到大的顺序排好)。

## 最长公共前缀(2021.04.07)
### 题目
	编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，则返回""
	比如：输入: ["flower","flow","flight"]
		 输出: "fl"
		 输入: ["dog","racecar","car"]
		 输出: ""
### 心路历程
   对于这种操作字符串的问题，我的第一想法是把每个字符串打散，分散成字符数组进行操作，但是这种想法实现起来可能会很复杂。之前对字符串的操作也不怎么熟悉，还是先看看人家是怎么解决的。
### 解题方法
``````
public static String getCommonPrefix(String[] strs) {
    if (strs.length < 1) {
        return "";
    }
    String common = strs[0];
    for (int i = 1; i< strs.length; i++) {
        while (strs[i].indexOf(common) != 0) {
            if (common.length() < 1) {
                return "";
            }
            common = common.substring(0,common.length() - 1);
        }
    }
    return common;
}
``````
### 题解分析
   首先分析一下题目，寻找 **最长** **公共** 字符串前缀，最长比较容易注意到，但是这个公共，我就给忽略了，一度认为人家的解题方法不正确。这里首先拿第一个字符串作为这个前缀，和后面的一个作比较，如果‘strs[i].indexOf(common) == 0’，那这个common就是两个字符串的公共前缀，这时去比较下一个，如果‘strs[i].indexOf(common) != 0’，那这个common就需要把把最后的字符去掉，这样可以得到公共字符串前缀。这种问题没什么感觉，可能需要多看看关于字符串的相关操作，培养字符串处理的思维。

## 买卖股票的最佳时机(2021.04.08)
### 题目
	给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。
	例如：输入: [7,1,5,3,6,4]
		 输出: 7
		 5-1=4，6-3=3，4+3=7
### 心路历程
   第一眼看到这种问题还是很懵的，仔细一看其实就是计算数组正差值最大和。以题目中的例子，第二天买入，第三天卖出，可以赚4块钱；之后第四天买入，第五天卖出，可以赚3块钱，一共可赚7块钱。
### 解题方法
```java
public static int maxProfit(int[] money) {
    if (money.length <= 1) {
        return 0;
    }
    int amount = 0;
    for (int i = 0; i < money.length - 1; i++) {
        if (money[i+1] > money[i]) {
            amount += money[i+1] - money[i];
        }
     }
    return amount;
}
```
### 题解分析
   这里用到的是贪心算法，每次只计算前后两天的差值，将正数差值加在一起，就能够算出符合题意的最大利润。
   PS：所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，它所做出的仅仅是在某种意义上的局部最优解。这道题属于相关题目中较为简单的一种，不需要考虑过多的情况，贪心算法的结果就是最优结果。
### 解题方法(复杂版)
```java
public int maxProfit(int[] prices) {
    int profits = 0;
    int n = prices.length;
    int[][] dp = new int[n][2];
    // 初始化为0  相等于卖出
    dp[0][0] = 0;
    // 相等于买入
    dp[0][1] = -prices[0];   
    for (int i = 1; i < prices.length; i++) {
    	// 此时的卖出值等于上一次的卖出后的值与当前进行卖出操作后的值 比较，取最大
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);  
        // 当前买入操作后的值等于 上一次买入后手里的值与 进行买入操作后剩余的值比较，取最大
        dp[i][1] = Math.max(dp[i-1][0] - prices[i], dp[i-1][1]); 
    }
	// 相当于卖出操作后手里的钱
    profits = dp[prices.length - 1][0];  
    return profits;
}
```
### 题解分析
   这个方法比较复杂，这里设置了两个状态，0-卖出、1-买入，在遍历数组的时候，分别分析每一天卖出和买入的利润，如果今天卖出的总利润大于上一次卖出后的总利润，则卖出，如果本次买入后手里的钱多于上一次买入后手里的钱，则买入。这个状态主要用于下一次判断是否卖出。